`Data.LanguageNames`: convert between language codes and language names
=======================================================================

One of the particularly difficult things about dealing with Wiktionary is
that information in different languages is often distinguished by the
human-readable name of the language, instead of by a language code.

This is largely for historical reasons, because many entries were written
before the many languages of Wiktionary were organized by a tangle of templates
and Lua code, so the problem is worse on Wiktionaries with more history
(English and German).

An entry defining a French word in English, for example, may be listed
as being in "French"; the same entry in German may be listed as being
in "Französisch"; and that entry in Japanese may sensibly be listed as
being in `{{fr}}`, which shows up as "フランス語" on the page. We want
to be able to recognize all of these as the language code `fr`.

This is a small part of what the Python module `langcodes` does, reimplemented
in Haskell. In fact, it gets most of its information from a file that's
generated by a Python script that uses `langcodes`.

> {-# LANGUAGE OverloadedStrings, NoImplicitPrelude #-}
>
> module Data.LanguageNames where
> import WikiPrelude

Most of the language names we need appear in `Data.LanguageNamesData`,
the module that the Python script described above generates.

> import Data.LanguageNamesData (languageData)

Given that information, we define `lookupLanguage`, whose first argument
is the language to look up language names in, and whose second argument
is the name to look up. We define a number of special cases that don't
appear in LanguageNamesData, then delegate the rest to LanguageNamesData.

The English and German Wiktionaries use some names that are not quite the name
that langcodes expects:

> lookupLanguage :: Language -> Text -> Language
> lookupLanguage "en" "Rapanui" = "rap"
> lookupLanguage "en" "Tok Pisin" = "tpi"
> lookupLanguage "en" "Bokmål" = "nb"
> lookupLanguage "de" "International" = "mul"

The French Wiktionary uses language codes for most purposes, but occasionally
there will be a link referring directly to a section of a page by spelling the
language name out in French. We need to be able to recognize those.

> lookupLanguage "fr" "Français" = "fr"
> lookupLanguage "fr" "Anglais" = "en"
> lookupLanguage "fr" "Italian" = "it"
> lookupLanguage "fr" "Italien" = "it"
> lookupLanguage "fr" "Allemand" = "de"
> lookupLanguage "fr" "Espagnol" = "es"

When defining multilingual conventions, the French Wiktionary uses the template
`{{conv}}`, where it would normally use a language code template such as `{{en}}`.
We want to consider this to be the same as the language code `mul`, for
"Multilingual" or "Multiple languages".

> lookupLanguage "fr" "conv" = "mul"

In other cases where a language is expected on the French Wiktionary, it will
just be defined by its standard language code.

> lookupLanguage "fr" code = toLanguage code

Any language we haven't named so far gets looked up in the `languageMap` that
is derived from LanguageNamesData.

> lookupLanguage lang name = findWithDefault "und" (lang, name) languageMap

Why doesn't LanguageNamesData define the map itself, as a big literal?  Well,
this is tragic, but the Haskell compiler is not good at handling big,
structured literals at all. In fact, what I ended up doing to make this not
take 10 minutes to compile was to make LanguageNamesData define nothing but an
enormous *string* of comma-separated values, which we parse into the
`languageMap` at runtime.

We read the CSV string by applying `entryTuple` to each line:

> languageMap :: Map (Language, Text) Language
> languageMap = mapFromList (map entryTuple (lines languageDataText))

`entryTuple` needs to give a (Language, Text) key and a (Language) value for
each line, which we extract from the three fields of the CSV.

We tell this function that its input is a Text, even though it's actually
a crappy old String. The `OverloadedStrings` language extension will convert
it to a Text automatically so it fits the type signature.

> entryTuple :: Text -> ((Language, Text), Language)
> entryTuple line =
>   let entry = splitSeq "," line
>       Just lang = index entry 0
>       Just name = index entry 1
>       Just code = index entry 2
>   in ((toLanguage lang, name), toLanguage code)

> languageDataText :: Text
> languageDataText = pack languageData


A note on indexing
------------------

`index`, used above, is the Classy Prelude's replacement for `!!`, the index
operator, which is the worst idea in Haskell. If you index something out of
bounds, `!!` crashes the program at runtime, making it a terrible default.

`index seq i` returns a `Maybe` value, which is either `Just` the `i`th element
of `seq`, or `Nothing` if it was out of bounds.  Of course, we're confident
enough that we're indexing in bounds here that we immediately pattern-match it
against `Just x`... which would crash the program with an undefined match
result if it got `Nothing`.

But at least we *chose* to do it this way, and we let the type system know what
we're doing.

